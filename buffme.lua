-- ======================================================================
-- BuffMe v1.0.10 (ImGui InputText Fix - SEARCH NOW WORKS!)
-- Project Lazarus - Tell-triggered group buff dispatcher (Controller GUI)
--
-- Fixes in v1.0.10:
--   - CRITICAL: Fixed ImGui.InputText() to use Lazarus-compatible pattern
--   - Search now works! Typing in search box properly updates query
--   - Fixed all InputText fields to use single-return pattern (matches SpellExport)
--   - Added extensive debug logging for troubleshooting
--
-- Fixes in v1.0.9:
--   - Fixed search results not being cached (search now works!)
--   - Lowered MAX_SPELL_ID to 30000 (matches SpellExport, appropriate for Lazarus)
--   - Progress bar now shows 100% when cache is complete
--   - Added note about E3 auto-pause behavior (expected, not a bug)
--
-- Fixes in v1.0.8:
--   - COMPLETE REWRITE of spell cache system using proven SpellExport approach
--   - Levenshtein distance fuzzy matching (tested and working)
--   - Proper spell validation that actually works on Lazarus EMU
--   - Fixed search index corruption
--   - Removed broken "by_first" indexing
--
-- Usage:
--   /lua run buffme.lua        (run on your driver/controller)
--   Anyone can /tell you: buff me
--   Your group will attempt to cast your configured buff list on them.
-- ======================================================================

local mq = require('mq')
local ImGui = require('ImGui')

local SCRIPT_NAME = 'BuffMe'
local SCRIPT_VER  = '1.0.10'

-- -----------------------------
-- FSM States
-- -----------------------------
local CACHE_STATE = {
  IDLE = 'IDLE',
  BUILDING = 'BUILDING',
  COMPLETE = 'COMPLETE',
  ERROR = 'ERROR'
}

-- -----------------------------
-- Paths
-- -----------------------------
local function getConfigDir()
  if mq.configDir then return mq.configDir end
  local p = mq.TLO.MacroQuest.Path('config')
  if p and p() and p() ~= '' then return p() end
  return '.'
end

local function joinPath(a, b)
  if not a or a == '' then return b end
  local lastChar = a:sub(-1)
  if lastChar == '/' or lastChar == '\\' then return a .. b end
  return a .. '/' .. b
end

local CONFIG_DIR      = getConfigDir()
local SETTINGS_FILE   = joinPath(CONFIG_DIR, 'buffme_settings.lua')
local SPELLCACHE_FILE = joinPath(CONFIG_DIR, 'buffme_spellcache.lua')

-- -----------------------------
-- Safe TLO Access
-- -----------------------------
local function safe(fn)
  local ok, r = pcall(fn)
  if ok then return r end
end

-- -----------------------------
-- String utilities
-- -----------------------------
local function trimString(s)
  if not s then return '' end
  local str = tostring(s)
  return str:gsub('^%s+', ''):gsub('%s+$', '')
end

local function safeString(s)
  if type(s) ~= 'string' then return '' end
  return tostring(s)
end

-- -----------------------------
-- Safe Lua serialization
-- -----------------------------
local function escStr(s)
  s = tostring(s or '')
  s = s:gsub('\\','\\\\')
  s = s:gsub('"','\\"')
  s = s:gsub('\r','\\r')
  s = s:gsub('\n','\\n')
  s = s:gsub('\t','\\t')
  return s
end

local function writeLuaReturnTable(path, t)
  local f, err = io.open(path, 'w+')
  if not f then 
    print(string.format('[%s] ERROR: Could not write to %s: %s', SCRIPT_NAME, path, tostring(err)))
    return false 
  end

  local function ser(v, indent)
    indent = indent or 0
    local pad = string.rep('  ', indent)

    if type(v) == 'number' then
      return tostring(v)
    elseif type(v) == 'boolean' then
      return v and 'true' or 'false'
    elseif type(v) == 'string' then
      return '"' .. escStr(v) .. '"'
    elseif type(v) == 'table' then
      local isArray, maxN = true, 0
      for k,_ in pairs(v) do
        if type(k) ~= 'number' then isArray = false break end
        if k > maxN then maxN = k end
      end

      local out = {}
      table.insert(out, '{')
      if isArray then
        for i=1,maxN do
          table.insert(out, pad .. '  ' .. ser(v[i], indent+1) .. ',')
        end
      else
        for k,val in pairs(v) do
          local key
          if type(k) == 'string' and k:match('^[%a_][%w_]*$') then
            key = k
          else
            key = '[' .. ser(k, indent+1) .. ']'
          end
          table.insert(out, pad .. '  ' .. key .. ' = ' .. ser(val, indent+1) .. ',')
        end
      end
      table.insert(out, pad .. '}')
      return table.concat(out, '\n')
    end
    return 'nil'
  end

  f:write('-- Auto-generated by ', SCRIPT_NAME, ' v', SCRIPT_VER, '\n')
  f:write('return ', ser(t, 0), '\n')
  f:close()
  return true
end

local function loadLuaTable(path)
  local f = loadfile(path)
  if not f then return nil end
  local ok, data = pcall(f)
  if ok and type(data) == 'table' then return data end
  return nil
end

-- -----------------------------
-- Settings
-- -----------------------------
local DEFAULT_SETTINGS = {
  enabled = true,
  triggerText = 'buff me',
  allowBackgroundCacheBuild = false,
  cooldownSecondsPerPlayer = 60,
  queueProcessDelayMs = 500,
  buffList = {},
  showDebug = false,
}

local settings = {}

for k, v in pairs(DEFAULT_SETTINGS) do
  if type(v) == 'table' then
    settings[k] = {}
  else
    settings[k] = v
  end
end

local uiState = {
  enabled = true,
  allowBackgroundCacheBuild = false,
  triggerText = 'buff me',
  showDebug = false,
}

local saveSettings

local function validateAndRepairSettings(t)
  if type(t) ~= 'table' then return false end
  
  local repaired = false
  
  if type(t.enabled) ~= 'boolean' then
    t.enabled = DEFAULT_SETTINGS.enabled
    repaired = true
  end
  
  if type(t.triggerText) ~= 'string' or t.triggerText == '' then
    t.triggerText = DEFAULT_SETTINGS.triggerText
    repaired = true
  end
  
  if type(t.allowBackgroundCacheBuild) ~= 'boolean' then
    t.allowBackgroundCacheBuild = DEFAULT_SETTINGS.allowBackgroundCacheBuild
    repaired = true
  end
  
  if type(t.cooldownSecondsPerPlayer) ~= 'number' then
    t.cooldownSecondsPerPlayer = DEFAULT_SETTINGS.cooldownSecondsPerPlayer
    repaired = true
  end
  
  if type(t.queueProcessDelayMs) ~= 'number' then
    t.queueProcessDelayMs = DEFAULT_SETTINGS.queueProcessDelayMs
    repaired = true
  end
  
  if type(t.buffList) ~= 'table' then
    t.buffList = {}
    repaired = true
  end
  
  if type(t.showDebug) ~= 'boolean' then
    t.showDebug = DEFAULT_SETTINGS.showDebug
    repaired = true
  end
  
  return repaired
end

saveSettings = function()
  if type(settings.enabled) ~= 'boolean' then return false end
  if type(settings.triggerText) ~= 'string' or settings.triggerText == '' then return false end
  if type(settings.allowBackgroundCacheBuild) ~= 'boolean' then return false end
  if type(settings.buffList) ~= 'table' then return false end
  
  local success = writeLuaReturnTable(SETTINGS_FILE, settings)
  if success then
    print(string.format('[%s] Settings saved', SCRIPT_NAME))
  end
  return success
end

local function syncUIFromSettings()
  uiState.enabled = (settings.enabled == true)
  uiState.allowBackgroundCacheBuild = (settings.allowBackgroundCacheBuild == true)
  uiState.triggerText = safeString(settings.triggerText)
  uiState.showDebug = (settings.showDebug == true)
end

local function loadSettings()
  local t = loadLuaTable(SETTINGS_FILE)
  local needsSave = false
  
  if type(t) == 'table' then
    if validateAndRepairSettings(t) then
      needsSave = true
    end
    
    settings.enabled = t.enabled
    settings.triggerText = t.triggerText
    settings.allowBackgroundCacheBuild = t.allowBackgroundCacheBuild
    settings.cooldownSecondsPerPlayer = t.cooldownSecondsPerPlayer
    settings.queueProcessDelayMs = t.queueProcessDelayMs
    settings.buffList = t.buffList
    settings.showDebug = t.showDebug
  else
    needsSave = true
  end
  
  syncUIFromSettings()
  
  if needsSave then
    saveSettings()
  end
end

-- -----------------------------
-- Spell Cache - SpellExport Style
-- -----------------------------
local MAX_SPELL_ID = 30000  -- Matches SpellExport (Lazarus EMU spell range)
local CACHE_BATCH = 500
local CACHE_SCHEMA_VERSION = 5  -- New schema for SpellExport-style caching
local MAX_LOOKUP_RESULTS = 30

local spellCache = {}
local cacheState = CACHE_STATE.IDLE
local cacheProgress = 0
local currentCacheID = 1
local cacheStats = {
  totalSpells = 0,
  lastBuildTime = 'Never',
  schemaVersion = 0
}

-- Levenshtein distance (from SpellExport - proven working)
local function levenshtein(a, b)
  a = a or ''
  b = b or ''
  local la, lb = #a, #b
  if la == 0 then return lb end
  if lb == 0 then return la end

  local prev = {}
  local curr = {}

  for j = 0, lb do
    prev[j] = j
  end

  for i = 1, la do
    curr[0] = i
    local ca = a:sub(i, i)
    for j = 1, lb do
      local cb = b:sub(j, j)
      local cost = (ca == cb) and 0 or 1
      local del  = prev[j]   + 1
      local ins  = curr[j-1] + 1
      local sub  = prev[j-1] + cost
      local v    = del
      if ins < v then v = ins end
      if sub < v then v = sub end
      curr[j] = v
    end
    prev, curr = curr, prev
  end

  return prev[lb]
end

local function loadCache()
  local data = loadLuaTable(SPELLCACHE_FILE)
  if not data then return false end
  
  -- Schema migration
  if not data.schemaVersion or data.schemaVersion < CACHE_SCHEMA_VERSION then
    print(string.format('[%s] Cache schema outdated (have %s, need %d) - rebuild required', 
      SCRIPT_NAME, tostring(data.schemaVersion or 0), CACHE_SCHEMA_VERSION))
    return false
  end
  
  if not data.spells or type(data.spells) ~= 'table' then
    return false
  end
  
  spellCache = data.spells
  cacheStats.totalSpells = #spellCache
  cacheStats.lastBuildTime = data.buildTime or 'Unknown'
  cacheStats.schemaVersion = data.schemaVersion or 0
  
  cacheState = CACHE_STATE.COMPLETE
  
  print(string.format('[%s] Loaded spell cache: %d spells', SCRIPT_NAME, #spellCache))
  return true
end

local function saveCache()
  local data = {
    schemaVersion = CACHE_SCHEMA_VERSION,
    buildTime = os.date('%Y-%m-%d %H:%M:%S'),
    spells = spellCache
  }
  
  if writeLuaReturnTable(SPELLCACHE_FILE, data) then
    cacheStats.lastBuildTime = data.buildTime
    cacheStats.schemaVersion = CACHE_SCHEMA_VERSION
    print(string.format('[%s] Spell cache saved: %d spells', SCRIPT_NAME, #spellCache))
    return true
  end
  
  return false
end

local function startCacheBuilding()
  if cacheState == CACHE_STATE.BUILDING or cacheState == CACHE_STATE.COMPLETE then
    return
  end
  
  spellCache = {}
  currentCacheID = 1
  cacheProgress = 0
  cacheState = CACHE_STATE.BUILDING
  
  print(string.format('[%s] Building spell cache using SpellExport algorithm...', SCRIPT_NAME))
end

local function buildCacheBatch()
  if cacheState ~= CACHE_STATE.BUILDING then return end
  
  local endID = math.min(currentCacheID + CACHE_BATCH - 1, MAX_SPELL_ID)
  
  for id = currentCacheID, endID do
    -- Use SpellExport's proven spell validation approach
    local sp = safe(function() return mq.TLO.Spell(id) end)
    if sp and sp.ID and sp.ID() and sp.ID() ~= 0 then
      local name = sp.Name and sp.Name() or nil
      if name and name ~= '' then
        -- Store spell with lowercase for searching
        table.insert(spellCache, {
          id = id,
          name = name,
          nameLower = name:lower()
        })
      end
    end
  end
  
  currentCacheID = endID + 1
  cacheProgress = math.floor((currentCacheID / MAX_SPELL_ID) * 100)
  
  if currentCacheID > MAX_SPELL_ID then
    cacheState = CACHE_STATE.COMPLETE
    cacheStats.totalSpells = #spellCache
    
    print(string.format('[%s] Cache build complete: %d spells', SCRIPT_NAME, #spellCache))
    
    -- Debug: Show sample entries
    if #spellCache > 0 then
      print(string.format('[%s] Sample cache entries:', SCRIPT_NAME))
      for i = 1, math.min(5, #spellCache) do
        local entry = spellCache[i]
        print(string.format('  [%d] ID=%s, name="%s", nameLower="%s"', 
          i, tostring(entry.id), tostring(entry.name), tostring(entry.nameLower)))
      end
    end
    
    if not saveCache() then
      print(string.format('[%s] WARNING: Failed to save cache', SCRIPT_NAME))
    end
  end
end

local function resetCache()
  spellCache = {}
  currentCacheID = 1
  cacheProgress = 0
  cacheState = CACHE_STATE.IDLE
  cacheStats.totalSpells = 0
  
  os.remove(SPELLCACHE_FILE)
  
  print(string.format('[%s] Cache cleared', SCRIPT_NAME))
end

-- -----------------------------
-- Spell Lookup - SpellExport Style
-- -----------------------------
local lookup = {
  query = '',
  lastProcessedQuery = '',
  results = {},
  selected = nil
}

local function getSpellSuggestions(prefix)
  prefix = trimString(prefix)
  
  print(string.format('[%s] Search called with: "%s"', SCRIPT_NAME, prefix))
  
  if prefix == '' or #prefix < 2 then 
    print(string.format('[%s] Search: query too short', SCRIPT_NAME))
    return {} 
  end
  
  if cacheState ~= CACHE_STATE.COMPLETE then
    print(string.format('[%s] Search: cache not ready (state=%s)', SCRIPT_NAME, cacheState))
    return {}
  end
  
  -- Return cached results if query hasn't changed
  if prefix == lookup.lastProcessedQuery then
    print(string.format('[%s] Search: returning cached results (%d matches)', SCRIPT_NAME, #lookup.results))
    return lookup.results
  end
  lookup.lastProcessedQuery = prefix

  print(string.format('[%s] Search: scanning %d spells for "%s"', SCRIPT_NAME, #spellCache, prefix))
  
  local search = prefix:lower()
  local matches = {}

  -- SpellExport's proven fuzzy matching algorithm
  for _, entry in ipairs(spellCache) do
    local key = entry.nameLower
    
    local score
    local startPos = key:find(search, 1, true)
    if startPos == 1 then
      -- Exact prefix match
      score = 0
    elseif startPos ~= nil then
      -- Contains the search string
      score = 1
    else
      -- Fuzzy match using Levenshtein
      local slice = key:sub(1, #search)
      score = 2 + levenshtein(search, slice)
    end
    
    -- Only include reasonable matches
    if score <= 10 then
      local display = entry.name
      if score == 0 then
        display = '★ ' .. entry.name
      elseif score == 1 then
        display = '• ' .. entry.name
      end
      
      table.insert(matches, {
        id = entry.id,
        name = entry.name,
        display = display,
        score = score
      })
    end
  end

  -- Sort by score, then alphabetically
  table.sort(matches, function(a, b)
    if a.score ~= b.score then return a.score < b.score end
    return a.name:lower() < b.name:lower()
  end)

  -- Return top results
  local results = {}
  for i = 1, math.min(#matches, MAX_LOOKUP_RESULTS) do
    results[i] = matches[i]
  end

  print(string.format('[%s] Search: found %d total matches, returning %d', SCRIPT_NAME, #matches, #results))
  
  -- CRITICAL FIX: Store results before returning them!
  lookup.results = results
  return results
end

-- -----------------------------
-- Broadcast auto-detect
-- -----------------------------
local function hasPlugin(name)
  local p = mq.TLO.Plugin(name)
  return p and p() ~= nil
end

local function detectBroadcast()
  if hasPlugin('e3') then
    return 'E3', '/e3bcga'
  end
  if hasPlugin('eqbc') then
    return 'EQBC', '/bcga'
  end
  return 'NONE', nil
end

local function sendToGroup(cmd)
  local mode, bc = detectBroadcast()
  if not bc then return false, 'No broadcast plugin detected (need E3Next or EQBC).' end
  mq.cmdf('%s %s', bc, cmd)
  return true, mode
end

-- -----------------------------
-- Buff request handling
-- -----------------------------
local state = {
  busy = false,
  queue = {},
  lastRequestAt = {},
  lastStatus = '',
  testName = '',
}

local function enqueueRequest(name)
  if not name or name == '' then return end
  local nl = name:lower()
  local now = os.time()
  local last = state.lastRequestAt[nl] or 0
  if (now - last) < (settings.cooldownSecondsPerPlayer or 60) then
    state.lastStatus = string.format('Ignored %s (cooldown).', name)
    return
  end
  state.lastRequestAt[nl] = now

  for _,n in ipairs(state.queue) do
    if n:lower() == nl then return end
  end
  table.insert(state.queue, name)
end

local function buildAgentCommand(targetName)
  return string.format('/lua run buffme_agent %s', targetName)
end

local function dispatchToGroup(targetName)
  local anyEnabled = false
  for _,rec in ipairs(settings.buffList) do
    if rec and rec.enabled and type(rec.name) == 'string' and rec.name ~= '' then
      anyEnabled = true
      break
    end
  end
  if not anyEnabled then
    state.lastStatus = 'No enabled buffs configured. Add spells in the GUI first.'
    return
  end

  local ok, modeOrErr = sendToGroup(buildAgentCommand(targetName))
  if not ok then
    state.lastStatus = 'Dispatch failed: ' .. tostring(modeOrErr)
    return
  end
  state.lastStatus = string.format('Dispatched buff request for %s via %s.', targetName, tostring(modeOrErr))
end

local function processQueue()
  if state.busy then return end
  if #state.queue == 0 then return end
  state.busy = true
  local targetName = table.remove(state.queue, 1)
  dispatchToGroup(targetName)
  mq.delay(settings.queueProcessDelayMs or 500)
  state.busy = false
end

-- -----------------------------
-- TELL event listener
-- -----------------------------
local function onTell(line)
  if not settings.enabled then return end
  if type(line) ~= 'string' then return end

  local sender, msg = line:match("^([^%s]+) tells you, '(.+)'")
  if not sender or not msg then return end

  local trigger = trimString(settings.triggerText or 'buff me'):lower()
  local m = trimString(msg):lower()
  
  if m == trigger then
    enqueueRequest(sender)
  end
end

mq.event('BuffMeTellAny', "#*# tells you, '#*#'", onTell)

-- -----------------------------
-- Buff list management
-- -----------------------------
local function buffListHas(name)
  local nl = name:lower()
  for _,rec in ipairs(settings.buffList) do
    if rec and type(rec.name)=='string' and rec.name:lower() == nl then
      return true
    end
  end
  return false
end

local function addBuffSpell(name)
  if not name or name == '' then return end
  if buffListHas(name) then return end
  table.insert(settings.buffList, {name=name, enabled=true})
  saveSettings()
end

local function removeBuffIndex(idx)
  if idx < 1 or idx > #settings.buffList then return end
  table.remove(settings.buffList, idx)
  saveSettings()
end

local function moveBuff(idx, dir)
  local j = idx + dir
  if idx < 1 or idx > #settings.buffList then return end
  if j < 1 or j > #settings.buffList then return end
  settings.buffList[idx], settings.buffList[j] = settings.buffList[j], settings.buffList[idx]
  saveSettings()
end

-- -----------------------------
-- Cache stats panel
-- -----------------------------
local function drawCacheStats()
  if not ImGui.CollapsingHeader('Spell Cache Stats (Debug)') then return end

  local cacheCount = #spellCache
  local pct = 0
  
  -- Fix: Show 100% when complete, actual progress otherwise
  if cacheState == CACHE_STATE.COMPLETE then
    pct = 1.0
  elseif MAX_SPELL_ID > 0 then
    pct = (currentCacheID / MAX_SPELL_ID)
  end
  
  local pctDisplay = math.floor(pct * 100 + 0.5)

  ImGui.Text(string.format('Cache File: %s', SPELLCACHE_FILE))
  ImGui.Text(string.format('Algorithm: SpellExport-style (proven working)'))
  ImGui.Separator()
  ImGui.Text(string.format('State: %s', cacheState))
  ImGui.Text(string.format('Schema: %d', cacheStats.schemaVersion))
  ImGui.Text(string.format('Built At: %s', cacheStats.lastBuildTime))
  ImGui.Text(string.format('Spells Cached: %d', cacheCount))
  ImGui.Text(string.format('Progress: %d / %d', math.min(currentCacheID, MAX_SPELL_ID), MAX_SPELL_ID))
  ImGui.ProgressBar(pct or 0, -1, 0, string.format('%d%%', pctDisplay))
  
  ImGui.Separator()
  ImGui.TextColored(1, 0.5, 0, 1, 'Warning: This will delete and rebuild the entire cache')
  if ImGui.Button('Force Reset Cache') then
    resetCache()
    print(string.format('[%s] Cache reset - click Build/Resume to rebuild', SCRIPT_NAME))
  end
end

-- -----------------------------
-- Tooltips
-- -----------------------------
local function tooltip(text)
  if ImGui.IsItemHovered() then
    ImGui.BeginTooltip()
    ImGui.PushTextWrapPos(500)
    ImGui.TextUnformatted(text)
    ImGui.PopTextWrapPos()
    ImGui.EndTooltip()
  end
end

-- -----------------------------
-- Check ImGui availability
-- -----------------------------
local function checkImGuiAvailable()
  local ok, result = pcall(function()
    local testOpen = true
    local opened = ImGui.Begin("__BuffMeTest__", testOpen, ImGuiWindowFlags.NoInputs)
    if opened then
      ImGui.End()
    end
    return true
  end)
  
  if not ok then
    return false
  end
  
  return result == true
end

-- -----------------------------
-- UI
-- -----------------------------
local ui = { open = true, available = false, lastError = nil }

local function drawUI()
  local ok, err = pcall(function()
    local title = string.format('%s v%s', SCRIPT_NAME, SCRIPT_VER)
    ui.open, _ = ImGui.Begin(title, ui.open, ImGuiWindowFlags.AlwaysAutoResize)
    if not ui.open then
      ImGui.End()
      return
    end

    buildCacheBatch()
    mq.doevents()

    syncUIFromSettings()

    local mode = detectBroadcast()
    ImGui.Text(string.format('Mode: %s | Trigger: "%s" | Enabled: %s', mode, safeString(settings.triggerText), tostring(settings.enabled)))
    ImGui.Separator()

    local enabledResult = ImGui.Checkbox('Enable Tell Trigger', uiState.enabled)
    if enabledResult ~= uiState.enabled then
      uiState.enabled = enabledResult
      settings.enabled = enabledResult
      print(string.format('[%s] Tell trigger %s', SCRIPT_NAME, enabledResult and 'ENABLED' or 'DISABLED'))
      saveSettings()
    end
    tooltip('When enabled, listens for tells matching your trigger text')
    
    ImGui.SameLine()
    
    local cacheResult = ImGui.Checkbox('Allow background cache build', uiState.allowBackgroundCacheBuild)
    if cacheResult ~= uiState.allowBackgroundCacheBuild then
      uiState.allowBackgroundCacheBuild = cacheResult
      settings.allowBackgroundCacheBuild = cacheResult
      print(string.format('[%s] Background cache build %s', SCRIPT_NAME, cacheResult and 'ENABLED' or 'DISABLED'))
      saveSettings()
    end
    tooltip('Allow spell cache to build even when this window is closed')

    ImGui.Separator()

    ImGui.TextUnformatted('Tell trigger text (case-insensitive exact match):')
    local trigInput = safeString(uiState.triggerText)
    local newTrig = ImGui.InputText('##trigger', trigInput, 64)
    if type(newTrig) == 'string' and newTrig ~= '' and newTrig ~= settings.triggerText then
      uiState.triggerText = newTrig
      settings.triggerText = newTrig
      print(string.format('[%s] Trigger text changed to: "%s"', SCRIPT_NAME, newTrig))
      saveSettings()
    end
    tooltip('Example: players send you /tell <driver> "buff me"')

    ImGui.Separator()

    if ImGui.CollapsingHeader('Spell Lookup (Add to Buff List)', ImGuiTreeNodeFlags.DefaultOpen) then
      ImGui.Text('Search for spell:')
      
      -- Debug: Log state every frame when section is open
      local debugMsg = string.format('[DEBUG] query="%s", len=%d, cacheState=%s', 
        lookup.query, #lookup.query, cacheState)
      
      -- FIX: Use SpellExport's working pattern (single return value)
      local newQuery = ImGui.InputText('##lookup', lookup.query, 256)
      if type(newQuery) == 'string' then
        if newQuery ~= lookup.query then
          print(string.format('[%s] InputText changed: "%s" -> "%s"', SCRIPT_NAME, lookup.query, newQuery))
          lookup.query = newQuery
          -- Immediately trigger search on input change
          if cacheState == CACHE_STATE.COMPLETE and newQuery ~= '' and #newQuery >= 2 then
            print(string.format('[%s] Triggering immediate search for: "%s"', SCRIPT_NAME, newQuery))
            lookup.results = getSpellSuggestions(newQuery)
          else
            lookup.results = {}
          end
        end
      end
      tooltip('Type spell name (e.g., "sow" or "spirit of wolf")')
      
      -- Debug output
      ImGui.SameLine()
      ImGui.TextDisabled(debugMsg)

      ImGui.SameLine()
      if ImGui.Button('Clear##lookup') then
        lookup.query = ''
        lookup.lastProcessedQuery = ''
        lookup.results = {}
        lookup.selected = nil
        print(string.format('[%s] Search cleared', SCRIPT_NAME))
      end
      tooltip('Clear search and selection')

      ImGui.SameLine()
      if ImGui.Button('Build/Resume Cache') then
        if cacheState == CACHE_STATE.IDLE then
          startCacheBuilding()
        end
      end
      tooltip('Start or resume building the spell cache')
      
      -- Debug: Force search button
      if settings.showDebug then
        ImGui.SameLine()
        if ImGui.Button('Force Search##debug') then
          print(string.format('[%s] FORCE SEARCH with query: "%s"', SCRIPT_NAME, lookup.query))
          if lookup.query ~= '' then
            lookup.lastProcessedQuery = '' -- Force reprocess
            lookup.results = getSpellSuggestions(lookup.query)
            print(string.format('[%s] Force search returned %d results', SCRIPT_NAME, #lookup.results))
          end
        end
        tooltip('[DEBUG] Manually trigger search with current query')
      end

      local cacheCount = #spellCache
      if cacheState == CACHE_STATE.COMPLETE then
        ImGui.TextColored(0, 1, 0, 1, string.format('Cache: READY (%d spells)', cacheCount))
      elseif cacheState == CACHE_STATE.BUILDING then
        ImGui.TextColored(1, 1, 0, 1, string.format('Cache: BUILDING... %d%% (%d spells)', cacheProgress, cacheCount))
      else
        ImGui.TextColored(1, 0.5, 0, 1, 'Cache: Not Built - Click "Build/Resume Cache"')
      end

      -- Display results
      local chosen = nil
      if #lookup.results > 0 then
        ImGui.TextDisabled(string.format('(%d match%s)', #lookup.results, #lookup.results ~= 1 and 'es' or ''))
        
        ImGui.BeginChild('##lookup_results', 0, 200, true)
        for _, entry in ipairs(lookup.results) do
          local label = string.format('[%d] %s', entry.id, entry.display)
          local sel = (entry.id == lookup.selected)
          
          if ImGui.Selectable(label, sel) then
            chosen = entry
          end
        end
        ImGui.EndChild()
      elseif lookup.query ~= '' and #lookup.query >= 2 and cacheState == CACHE_STATE.COMPLETE then
        ImGui.TextDisabled('(no matches)')
      elseif cacheState ~= CACHE_STATE.COMPLETE and lookup.query ~= '' then
        ImGui.TextColored(1, 0.5, 0, 1, 'Cache not ready - build cache first')
      else
        ImGui.TextDisabled('(Type to search)')
      end

      if chosen then
        lookup.selected = chosen.id
        
        ImGui.Separator()
        ImGui.Text(string.format('Selected: %s [%d]', chosen.name, chosen.id))
        
        local canAdd = not buffListHas(chosen.name)
        if not canAdd then
          ImGui.TextColored(1, 0.5, 0, 1, '(Already in buff list)')
        end
        if ImGui.Button('Add Selected Spell') and canAdd then
          addBuffSpell(chosen.name)
          print(string.format('[%s] Added spell to buff list: %s', SCRIPT_NAME, chosen.name))
        end
      end
    end

    ImGui.Separator()

    if ImGui.CollapsingHeader('Buff List (What gets cast)', ImGuiTreeNodeFlags.DefaultOpen) then
      if #settings.buffList == 0 then
        ImGui.TextColored(0.7, 0.7, 0.7, 1, '(No buffs configured yet. Use Spell Lookup above to add spells.)')
      end

      for i,rec in ipairs(settings.buffList) do
        ImGui.PushID(i)
        
        local currentEnabled = (rec.enabled == true)
        local enabledResult = ImGui.Checkbox('##enabled', currentEnabled)
        if enabledResult ~= currentEnabled then
          rec.enabled = enabledResult
          print(string.format('[%s] Buff "%s" %s', SCRIPT_NAME, rec.name, enabledResult and 'ENABLED' or 'DISABLED'))
          saveSettings()
        end
        
        ImGui.SameLine()
        ImGui.TextUnformatted(rec.name or '')

        ImGui.SameLine()
        if ImGui.Button('Up') then moveBuff(i, -1) end
        ImGui.SameLine()
        if ImGui.Button('Dn') then moveBuff(i, 1) end
        ImGui.SameLine()
        if ImGui.Button('Remove') then 
          print(string.format('[%s] Removed spell from buff list: %s', SCRIPT_NAME, rec.name))
          removeBuffIndex(i) 
        end

        ImGui.PopID()
      end
    end

    ImGui.Separator()

    if ImGui.CollapsingHeader('Manual Test / Queue', ImGuiTreeNodeFlags.DefaultOpen) then
      ImGui.TextUnformatted('Last Status:')
      ImGui.TextColored(0.8, 0.8, 0.8, 1, state.lastStatus or '(none)')

      ImGui.Separator()
      ImGui.Text(string.format('Queue: %d pending', #state.queue))
      if ImGui.Button('Process Queue Now') then
        processQueue()
      end
      ImGui.SameLine()
      if ImGui.Button('Clear Queue') then
        state.queue = {}
        state.lastStatus = 'Queue cleared.'
      end

      ImGui.Separator()
      ImGui.TextUnformatted('Test by name:')
      local testName = state.testName or ''
      local newTest = ImGui.InputText('##testname', testName, 64)
      if type(newTest) == 'string' then
        state.testName = newTest
      end
      ImGui.SameLine()
      if ImGui.Button('Enqueue Test') then
        if state.testName and state.testName ~= '' then
          enqueueRequest(state.testName)
          state.lastStatus = 'Enqueued test request for ' .. state.testName
        end
      end
    end

    ImGui.Separator()

    local debugResult = ImGui.Checkbox('Show debug panels', uiState.showDebug)
    if debugResult ~= uiState.showDebug then
      uiState.showDebug = debugResult
      settings.showDebug = debugResult
      saveSettings()
    end
    if settings.showDebug then
      drawCacheStats()
    end

    ImGui.End()
  end)
  
  if not ok then
    ui.available = false
    ui.lastError = tostring(err)
    print(string.format('[%s] ImGui ERROR: %s', SCRIPT_NAME, err))
    print(string.format('[%s] Switching to HEADLESS mode. Tell trigger still active.', SCRIPT_NAME))
  end
end

-- -----------------------------
-- Init
-- -----------------------------
local function init()
  print(string.format('[%s] v%s initializing...', SCRIPT_NAME, SCRIPT_VER))
  print(string.format('[%s] Using SpellExport-style cache system', SCRIPT_NAME))
  
  loadSettings()
  print(string.format('[%s] Settings loaded: enabled=%s, trigger="%s"', SCRIPT_NAME, tostring(settings.enabled), settings.triggerText))
  
  local cacheLoaded = loadCache()
  
  -- Sanity check: if cache has way too many spells, it's corrupted
  if cacheLoaded and #spellCache > (MAX_SPELL_ID * 2) then
    print(string.format('[%s] WARNING: Cache has %d spells (expected max %d) - cache is corrupted!', 
      SCRIPT_NAME, #spellCache, MAX_SPELL_ID))
    print(string.format('[%s] Forcing cache rebuild...', SCRIPT_NAME))
    resetCache()
    cacheLoaded = false
  end
  
  if not cacheLoaded then
    print(string.format('[%s] Cache not found or outdated - build required', SCRIPT_NAME))
  end
  
  ui.available = checkImGuiAvailable()
  
  if ui.available then
    print(string.format('[%s] ImGui functional - starting with UI', SCRIPT_NAME))
    local ok, err = pcall(function()
      mq.imgui.init(SCRIPT_NAME, drawUI)
    end)
    if not ok then
      print(string.format('[%s] ImGui init failed: %s', SCRIPT_NAME, tostring(err)))
      ui.available = false
    end
  end
  
  if not ui.available then
    print(string.format('[%s] ==========================================', SCRIPT_NAME))
    print(string.format('[%s] RUNNING IN HEADLESS MODE (No UI)', SCRIPT_NAME))
    print(string.format('[%s] Tell trigger is ACTIVE', SCRIPT_NAME))
    print(string.format('[%s] ==========================================', SCRIPT_NAME))
  end
  
  print(string.format('[%s] Initialization complete. Enabled: %s', SCRIPT_NAME, tostring(settings.enabled)))
  
  -- E3 Compatibility Note
  if hasPlugin('e3') then
    print(string.format('[%s] NOTE: E3Next detected. E3 may auto-pause when BuffMe starts (this is normal E3 behavior).', SCRIPT_NAME))
    print(string.format('[%s] If E3 paused, use "/e3 resume" to restart it.', SCRIPT_NAME))
  end
end

init()

-- -----------------------------
-- Main loop
-- -----------------------------
print(string.format('[%s] Entering main loop...', SCRIPT_NAME))

while true do
  mq.delay(25)
  mq.doevents()
  processQueue()
  
  if cacheState == CACHE_STATE.BUILDING then
    if settings.allowBackgroundCacheBuild or (ui.available and ui.open) then
      buildCacheBatch()
    end
  end
  
  if not ui.available and ui.lastError then
    ui.lastError = nil
  end
end
