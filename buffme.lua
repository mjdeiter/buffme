-- ======================================================================
-- BuffMe v1.0.0 (Refactored)
-- Project Lazarus - Tell-triggered group buff dispatcher (Controller GUI)
--
-- Improvements over v0.9.0:
--   - Explicit FSM for cache building
--   - ImGui availability detection
--   - Enhanced error recovery
--   - Headless mode support
--   - Better diagnostic logging
--
-- Usage:
--   /lua run buffme.lua        (run on your driver/controller)
--   Anyone can /tell you: buff me
--   Your group will attempt to cast your configured buff list on them.
--
-- Broadcast Auto-Detect:
--   - Prefers E3Next: /e3bcga
--   - Falls back to EQBC: /bcga   (requires eqbc plugin)
--
-- Files:
--   buffme_settings.lua   (persistent config + buff list)
--   buffme_spellcache.lua (persistent spell name cache for lookup)
--   buffme_agent.lua      (run on group members on demand)
-- ======================================================================

local mq = require('mq')
local ImGui = require('ImGui')

local SCRIPT_NAME = 'BuffMe'
local SCRIPT_VER  = '1.0.0'

-- -----------------------------
-- FSM States
-- -----------------------------
local CacheState = {
  IDLE = 'IDLE',
  BUILDING = 'BUILDING',
  COMPLETE = 'COMPLETE',
  ERROR = 'ERROR'
}

-- -----------------------------
-- Paths
-- -----------------------------
local function getConfigDir()
  if mq.configDir then return mq.configDir end
  local p = mq.TLO.MacroQuest.Path('config')
  if p and p() and p() ~= '' then return p() end
  return '.'
end

local function joinPath(a, b)
  if not a or a == '' then return b end
  local lastChar = a:sub(-1)
  if lastChar == '/' or lastChar == '\\' then return a .. b end
  return a .. '/' .. b
end

local CONFIG_DIR      = getConfigDir()
local SETTINGS_FILE   = joinPath(CONFIG_DIR, 'buffme_settings.lua')
local SPELLCACHE_FILE = joinPath(CONFIG_DIR, 'buffme_spellcache.lua')

-- -----------------------------
-- String utilities
-- -----------------------------
local function trimString(s)
  if not s then return '' end
  local str = tostring(s)
  -- Remove leading whitespace
  while str:match('^%s') do
    str = str:sub(2)
  end
  -- Remove trailing whitespace
  while str:match('%s$') do
    str = str:sub(1, -2)
  end
  return str
end

-- -----------------------------
-- Safe Lua serialization
-- -----------------------------
local function escStr(s)
  s = tostring(s or '')
  s = s:gsub('\\','\\\\')
  s = s:gsub('"','\\"')
  s = s:gsub('\r','\\r')
  s = s:gsub('\n','\\n')
  s = s:gsub('\t','\\t')
  return s
end

local function writeLuaReturnTable(path, t)
  local f = io.open(path, 'w+')
  if not f then return false end

  local function ser(v, indent)
    indent = indent or 0
    local pad = string.rep('  ', indent)

    if type(v) == 'number' then
      return tostring(v)
    elseif type(v) == 'boolean' then
      return v and 'true' or 'false'
    elseif type(v) == 'string' then
      return '"' .. escStr(v) .. '"'
    elseif type(v) == 'table' then
      local isArray, maxN = true, 0
      for k,_ in pairs(v) do
        if type(k) ~= 'number' then isArray = false break end
        if k > maxN then maxN = k end
      end

      local out = {}
      table.insert(out, '{')
      if isArray then
        for i=1,maxN do
          table.insert(out, pad .. '  ' .. ser(v[i], indent+1) .. ',')
        end
      else
        for k,val in pairs(v) do
          local key
          if type(k) == 'string' and k:match('^[%a_][%w_]*$') then
            key = k
          else
            key = '[' .. ser(k, indent+1) .. ']'
          end
          table.insert(out, pad .. '  ' .. key .. ' = ' .. ser(val, indent+1) .. ',')
        end
      end
      table.insert(out, pad .. '}')
      return table.concat(out, '\n')
    end
    return 'nil'
  end

  f:write('-- Auto-generated by ', SCRIPT_NAME, ' v', SCRIPT_VER, '\n')
  f:write('return ', ser(t, 0), '\n')
  f:close()
  return true
end

local function loadLuaTable(path)
  local ok, t = pcall(dofile, path)
  if ok and type(t) == 'table' then return t end
  return nil
end

-- -----------------------------
-- Settings
-- -----------------------------
local settings = {
  enabled = true,
  triggerText = 'buff me',
  allowBackgroundCacheBuild = false,
  cooldownSecondsPerPlayer = 60,
  queueProcessDelayMs = 500,
  buffList = {},
  showDebug = false,
}

local function loadSettings()
  local t = loadLuaTable(SETTINGS_FILE)
  if type(t) == 'table' then
    for k,v in pairs(settings) do
      if t[k] ~= nil then settings[k] = t[k] end
    end
  end
  if type(settings.buffList) ~= 'table' then 
    settings.buffList = {} 
  end
  if type(settings.triggerText) ~= 'string' or settings.triggerText == '' then 
    settings.triggerText = 'buff me' 
  end
  if type(settings.cooldownSecondsPerPlayer) ~= 'number' then 
    settings.cooldownSecondsPerPlayer = 60 
  end
  if type(settings.queueProcessDelayMs) ~= 'number' then
    settings.queueProcessDelayMs = 500
  end
end

local function saveSettings()
  writeLuaReturnTable(SETTINGS_FILE, settings)
end

-- -----------------------------
-- Spell Cache with FSM
-- -----------------------------
local MAX_SPELL_ID = 60000
local CACHE_STEP_PER_TICK = 250
local CACHE_AUTOSAVE_EVERY = 2000
local CACHE_SCHEMA_VERSION = 1

local spellCache = {
  schema = CACHE_SCHEMA_VERSION,
  built_at = nil,
  max_spell_id = MAX_SPELL_ID,
  scanned_to = 0,
  state = CacheState.IDLE,
  error_message = nil,
  spells = {},
  by_first = {},
}

local cacheBuild = {
  started_at = nil,
  started_at_str = nil,
  lastAutosaveAt = 0,
}

local function nowStamp()
  return os.date('%Y-%m-%d %H:%M:%S')
end

local function getFileSize(path)
  local f = io.open(path, 'rb')
  if not f then return 0 end
  local ok, sz = pcall(function()
    local cur = f:seek()
    local size = f:seek('end')
    f:seek('set', cur or 0)
    return size or 0
  end)
  f:close()
  if ok and type(sz) == 'number' then return sz end
  return 0
end

local function transitionCacheState(newState, errorMsg)
  if spellCache.state ~= newState then
    print(string.format('[%s] Cache: %s -> %s', SCRIPT_NAME, spellCache.state, newState))
    spellCache.state = newState
    if errorMsg then
      spellCache.error_message = errorMsg
      print(string.format('[%s] Cache Error: %s', SCRIPT_NAME, errorMsg))
    else
      spellCache.error_message = nil
    end
  end
end

local function rebuildCacheIndex()
  spellCache.by_first = {}
  for i,rec in ipairs(spellCache.spells) do
    if type(rec) == 'table' then
      local nm = rec.name_lc or (rec.name and tostring(rec.name):lower()) or ''
      rec.name_lc = nm
      local first = nm:sub(1,1)
      if first == '' then first = '#' end
      spellCache.by_first[first] = spellCache.by_first[first] or {}
      table.insert(spellCache.by_first[first], i)
    end
  end
end

local function loadSpellCache()
  local t = loadLuaTable(SPELLCACHE_FILE)
  if type(t) ~= 'table' or type(t.spells) ~= 'table' then
    transitionCacheState(CacheState.IDLE)
    rebuildCacheIndex()
    return false
  end
  if not t.schema then t.schema = 1 end
  if tonumber(t.schema) ~= CACHE_SCHEMA_VERSION then
    transitionCacheState(CacheState.IDLE)
    rebuildCacheIndex()
    return false
  end
  
  spellCache.schema = t.schema
  spellCache.built_at = t.built_at
  spellCache.max_spell_id = t.max_spell_id or MAX_SPELL_ID
  spellCache.scanned_to = t.scanned_to or 0
  spellCache.spells = t.spells
  
  -- Determine state from loaded data
  if t.scanned_to and t.scanned_to >= (t.max_spell_id or MAX_SPELL_ID) then
    transitionCacheState(CacheState.COMPLETE)
  else
    transitionCacheState(CacheState.IDLE)
  end
  
  rebuildCacheIndex()
  return true
end

local function saveSpellCache()
  local t = {
    schema = spellCache.schema,
    built_at = spellCache.built_at,
    max_spell_id = spellCache.max_spell_id,
    scanned_to = spellCache.scanned_to,
    spells = spellCache.spells,
  }
  return writeLuaReturnTable(SPELLCACHE_FILE, t)
end

local function getSpellName(spellId)
  local sp = mq.TLO.Spell(spellId)
  if not sp or not sp() then return nil end
  local nm = sp.Name and sp.Name() or nil
  if not nm or nm == '' then return nil end
  local l = nm:lower()
  if l == 'null' or l == 'unknown' or l == 'unknown spell' then return nil end
  return nm
end

local function startCacheBuild(resume)
  if spellCache.state == CacheState.BUILDING then return end
  
  transitionCacheState(CacheState.BUILDING)
  cacheBuild.started_at = os.time()
  cacheBuild.started_at_str = nowStamp()
  cacheBuild.lastAutosaveAt = spellCache.scanned_to

  if not resume then
    spellCache.spells = {}
    spellCache.scanned_to = 0
    spellCache.built_at = nil
    rebuildCacheIndex()
  end

  spellCache.schema = CACHE_SCHEMA_VERSION
  spellCache.max_spell_id = MAX_SPELL_ID
  saveSpellCache()
end

local function stopCacheBuild()
  if spellCache.state == CacheState.BUILDING then
    transitionCacheState(CacheState.IDLE)
  end
end

local function cacheBuildStep()
  if spellCache.state ~= CacheState.BUILDING then return end

  local ok, err = pcall(function()
    local startId = spellCache.scanned_to + 1
    local endId = math.min(spellCache.scanned_to + CACHE_STEP_PER_TICK, spellCache.max_spell_id)

    for id = startId, endId do
      local nm = getSpellName(id)
      if nm and nm ~= '' then
        local rec = { id = id, name = nm, name_lc = nm:lower() }
        table.insert(spellCache.spells, rec)

        local idx = #spellCache.spells
        local first = rec.name_lc:sub(1,1)
        if first == '' then first = '#' end
        spellCache.by_first[first] = spellCache.by_first[first] or {}
        table.insert(spellCache.by_first[first], idx)
      end
    end

    spellCache.scanned_to = endId

    if (spellCache.scanned_to - cacheBuild.lastAutosaveAt) >= CACHE_AUTOSAVE_EVERY then
      cacheBuild.lastAutosaveAt = spellCache.scanned_to
      saveSpellCache()
    end

    if spellCache.scanned_to >= spellCache.max_spell_id then
      spellCache.built_at = nowStamp()
      saveSpellCache()
      transitionCacheState(CacheState.COMPLETE)
    end
  end)

  if not ok then
    transitionCacheState(CacheState.ERROR, tostring(err))
    saveSpellCache()
  end
end

local function ensureCacheBuilding()
  if spellCache.state == CacheState.BUILDING then return end
  if spellCache.state == CacheState.ERROR then
    transitionCacheState(CacheState.IDLE)
  end
  
  local hasAny = type(spellCache.spells) == 'table' and #spellCache.spells > 0
  if not hasAny and spellCache.scanned_to == 0 then
    startCacheBuild(false)
    return
  end
  if spellCache.state ~= CacheState.COMPLETE then
    startCacheBuild(true)
  end
end

-- -----------------------------
-- Broadcast auto-detect
-- -----------------------------
local function hasPlugin(name)
  local p = mq.TLO.Plugin(name)
  return p and p() ~= nil
end

local function detectBroadcast()
  if hasPlugin('e3') then
    return 'E3', '/e3bcga'
  end
  if hasPlugin('eqbc') then
    return 'EQBC', '/bcga'
  end
  return 'NONE', nil
end

local function sendToGroup(cmd)
  local mode, bc = detectBroadcast()
  if not bc then return false, 'No broadcast plugin detected (need E3Next or EQBC).' end
  mq.cmdf('%s %s', bc, cmd)
  return true, mode
end

-- -----------------------------
-- Buff request handling
-- -----------------------------
local state = {
  busy = false,
  queue = {},
  lastRequestAt = {},
  lastStatus = '',
  testName = '',
}

local function enqueueRequest(name)
  if not name or name == '' then return end
  local nl = name:lower()
  local now = os.time()
  local last = state.lastRequestAt[nl] or 0
  if (now - last) < (settings.cooldownSecondsPerPlayer or 60) then
    state.lastStatus = string.format('Ignored %s (cooldown).', name)
    return
  end
  state.lastRequestAt[nl] = now

  for _,n in ipairs(state.queue) do
    if n:lower() == nl then return end
  end
  table.insert(state.queue, name)
end

local function buildAgentCommand(targetName)
  return string.format('/lua run buffme_agent %s', targetName)
end

local function dispatchToGroup(targetName)
  local anyEnabled = false
  for _,rec in ipairs(settings.buffList) do
    if rec and rec.enabled and type(rec.name) == 'string' and rec.name ~= '' then
      anyEnabled = true
      break
    end
  end
  if not anyEnabled then
    state.lastStatus = 'No enabled buffs configured. Add spells in the GUI first.'
    return
  end

  local ok, modeOrErr = sendToGroup(buildAgentCommand(targetName))
  if not ok then
    state.lastStatus = 'Dispatch failed: ' .. tostring(modeOrErr)
    return
  end
  state.lastStatus = string.format('Dispatched buff request for %s via %s.', targetName, tostring(modeOrErr))
end

local function processQueue()
  if state.busy then return end
  if #state.queue == 0 then return end
  state.busy = true
  local targetName = table.remove(state.queue, 1)
  dispatchToGroup(targetName)
  mq.delay(settings.queueProcessDelayMs or 500)
  state.busy = false
end

-- -----------------------------
-- TELL event listener
-- -----------------------------
local function onTell(line)
  if not settings.enabled then return end
  if type(line) ~= 'string' then return end

  local sender, msg = line:match("^([^%s]+) tells you, '(.+)'")
  if not sender or not msg then return end

  local trigger = trimString(settings.triggerText or 'buff me'):lower()
  local m = trimString(msg):lower()
  
  if m == trigger then
    enqueueRequest(sender)
  end
end

mq.event('BuffMeTellAny', "#*# tells you, '#*#'", onTell)

-- -----------------------------
-- Lookup (simple fuzzy)
-- -----------------------------
local function startsWith(s, prefix) return s:sub(1, #prefix) == prefix end
local function contains(s, needle) return s:find(needle, 1, true) ~= nil end

local function fuzzyScore(q, text)
  if q == '' then return 0 end
  local qi, ti = 1, 1
  local score = 0
  local lastMatch = 0
  while qi <= #q and ti <= #text do
    local qc = q:sub(qi, qi)
    local tc = text:sub(ti, ti)
    if qc == tc then
      score = score + 10
      if lastMatch == ti - 1 then score = score + 5 end
      lastMatch = ti
      qi = qi + 1
      ti = ti + 1
    else
      score = score - 1
      ti = ti + 1
    end
  end
  if qi <= #q then return 0 end
  score = score - math.floor(#text / 25)
  return score
end

local lookup = { query = '', dirty = true, results = {}, selected = nil }

local function computeLookup()
  lookup.results = {}
  lookup.selected = nil

  local q = trimString(lookup.query or ''):lower()
  if q == '' then return end

  ensureCacheBuilding()
  
  if type(spellCache.spells) ~= 'table' then
    print(string.format('[%s] Warning: spellCache.spells is not a table', SCRIPT_NAME))
    return
  end

  local first = q:sub(1,1)
  local candidates = spellCache.by_first[first]
  local scored = {}

  local function consider(i)
    if type(i) ~= 'number' or i < 1 or i > #spellCache.spells then return end
    
    local rec = spellCache.spells[i]
    if type(rec) ~= 'table' then return end
    
    local nm = rec.name_lc or (rec.name and tostring(rec.name):lower()) or ''
    if nm == '' then return end

    local score = 0
    if startsWith(nm, q) then
      score = 10000 - #nm
    elseif contains(nm, q) then
      score = 8000 - #nm
    else
      local fs = fuzzyScore(q, nm)
      if fs <= 0 then return end
      score = 1000 + fs
    end
    table.insert(scored, {idx=i, score=score})
  end

  if candidates and type(candidates) == 'table' and #candidates > 0 then
    for _,i in ipairs(candidates) do consider(i) end
  else
    for i=1,#spellCache.spells do consider(i) end
  end

  table.sort(scored, function(a,b)
    if a.score == b.score then
      local aRec = spellCache.spells[a.idx]
      local bRec = spellCache.spells[b.idx]
      local aName = (type(aRec) == 'table' and aRec.name_lc) or ''
      local bName = (type(bRec) == 'table' and bRec.name_lc) or ''
      return aName < bName
    end
    return a.score > b.score
  end)

  for i=1,math.min(30, #scored) do
    table.insert(lookup.results, scored[i].idx)
  end
end

-- -----------------------------
-- Buff list management
-- -----------------------------
local function buffListHas(name)
  local nl = name:lower()
  for _,rec in ipairs(settings.buffList) do
    if rec and type(rec.name)=='string' and rec.name:lower() == nl then
      return true
    end
  end
  return false
end

local function addBuffSpell(name)
  if not name or name == '' then return end
  if buffListHas(name) then return end
  table.insert(settings.buffList, {name=name, enabled=true})
  saveSettings()
end

local function removeBuffIndex(idx)
  if idx < 1 or idx > #settings.buffList then return end
  table.remove(settings.buffList, idx)
  saveSettings()
end

local function moveBuff(idx, dir)
  local j = idx + dir
  if idx < 1 or idx > #settings.buffList then return end
  if j < 1 or j > #settings.buffList then return end
  settings.buffList[idx], settings.buffList[j] = settings.buffList[j], settings.buffList[idx]
  saveSettings()
end

-- -----------------------------
-- Cache stats panel
-- -----------------------------
local function drawCacheStats()
  if not ImGui.CollapsingHeader('Spell Cache Stats (Debug)') then return end

  local cacheCount = (type(spellCache.spells)=='table') and #spellCache.spells or 0
  local pct = 0
  if spellCache.max_spell_id and spellCache.max_spell_id > 0 then
    pct = (spellCache.scanned_to / spellCache.max_spell_id)
  end

  ImGui.Text(string.format('Cache File: %s', SPELLCACHE_FILE))
  ImGui.Text(string.format('File Size: %d bytes', getFileSize(SPELLCACHE_FILE)))
  ImGui.Separator()
  ImGui.Text(string.format('State: %s', spellCache.state))
  if spellCache.error_message then
    ImGui.TextColored(1, 0, 0, 1, string.format('Error: %s', spellCache.error_message))
  end
  ImGui.Text(string.format('Built At: %s', tostring(spellCache.built_at or 'n/a')))
  ImGui.Text(string.format('Spells Cached: %d', cacheCount))
  ImGui.Text(string.format('Progress: %d / %d', spellCache.scanned_to or 0, spellCache.max_spell_id or 0))
  ImGui.ProgressBar(pct or 0, -1, 0, string.format('%d%%', math.floor((pct or 0)*100)))
  
  if ImGui.Button('Force Reset Cache') then
    spellCache.spells = {}
    spellCache.scanned_to = 0
    spellCache.built_at = nil
    transitionCacheState(CacheState.IDLE)
    rebuildCacheIndex()
    saveSpellCache()
  end
end

-- -----------------------------
-- Tooltips
-- -----------------------------
local function tooltip(text)
  if ImGui.IsItemHovered() then
    ImGui.BeginTooltip()
    ImGui.PushTextWrapPos(500)
    ImGui.TextUnformatted(text)
    ImGui.PopTextWrapPos()
    ImGui.EndTooltip()
  end
end

-- -----------------------------
-- Check ImGui availability
-- -----------------------------
local function checkImGuiAvailable()
  local ok, result = pcall(function()
    local testOpen = true
    local opened = ImGui.Begin("__BuffMeTest__", testOpen, ImGuiWindowFlags.NoInputs)
    if opened then
      ImGui.End()
    end
    return true
  end)
  
  if not ok then
    return false
  end
  
  return result == true
end

-- -----------------------------
-- UI
-- -----------------------------
local ui = { open = true, available = false, lastError = nil }

local function drawUI()
  local ok, err = pcall(function()
    local title = string.format('%s v%s', SCRIPT_NAME, SCRIPT_VER)
    ui.open, _ = ImGui.Begin(title, ui.open, ImGuiWindowFlags.AlwaysAutoResize)
    if not ui.open then
      ImGui.End()
      return
    end

    cacheBuildStep()
    mq.doevents()

    local mode = detectBroadcast()
    ImGui.Text(string.format('Mode: %s | Trigger: "%s" | Enabled: %s', mode, settings.triggerText, tostring(settings.enabled)))
    ImGui.Separator()

    local changed
    changed, settings.enabled = ImGui.Checkbox('Enable Tell Trigger', settings.enabled)
    if changed then saveSettings() end
    ImGui.SameLine()
    changed, settings.allowBackgroundCacheBuild = ImGui.Checkbox('Allow background cache build', settings.allowBackgroundCacheBuild)
    if changed then saveSettings() end

    ImGui.Separator()

    ImGui.TextUnformatted('Tell trigger text (case-insensitive exact match):')
    local trig = settings.triggerText or 'buff me'
    local te
    te, trig = ImGui.InputText('##trigger', trig, 64)
    if te then
      settings.triggerText = trig
      saveSettings()
    end
    tooltip('Example: players send you /tell <driver> "buff me"')

    ImGui.Separator()

    if ImGui.CollapsingHeader('Spell Lookup (Add to Buff List)', ImGuiTreeNodeFlags.DefaultOpen) then
      local q = lookup.query or ''
      local qe
      qe, q = ImGui.InputTextWithHint('##lookup', 'Type spell name...', q, 128)
      if qe then
        lookup.query = q
        lookup.dirty = true
      end

      ImGui.SameLine()
      if ImGui.Button('Clear##lookup') then
        lookup.query = ''
        lookup.dirty = true
        lookup.selected = nil
      end

      ImGui.SameLine()
      if ImGui.Button('Build/Resume Cache') then
        ensureCacheBuilding()
      end

      local cacheCount = (type(spellCache.spells)=='table') and #spellCache.spells or 0
      if spellCache.state == CacheState.COMPLETE then
        ImGui.Text(string.format('Cache: complete (%d spells)', cacheCount))
      elseif spellCache.state == CacheState.BUILDING then
        ImGui.Text(string.format('Cache: building (%d spells, scanned %d/%d)', cacheCount, spellCache.scanned_to, spellCache.max_spell_id))
      elseif spellCache.state == CacheState.ERROR then
        ImGui.TextColored(1, 0, 0, 1, string.format('Cache: ERROR (%d spells)', cacheCount))
      else
        ImGui.Text(string.format('Cache: idle (%d spells)', cacheCount))
      end

      if lookup.dirty then
        lookup.dirty = false
        computeLookup()
      end

      ImGui.BeginChild('##lookup_results', 0, 180, true)
      if (lookup.query or '') == '' then
        ImGui.TextUnformatted('(Type to search)')
      else
        if #lookup.results == 0 then
          ImGui.TextUnformatted('(No matches)')
        else
          for _,idx in ipairs(lookup.results) do
            local rec = spellCache.spells[idx]
            if rec then
              local label = string.format('%s (%d)', rec.name or 'Unknown', rec.id or 0)
              if ImGui.Selectable(label, lookup.selected == idx) then
                lookup.selected = idx
              end
            end
          end
        end
      end
      ImGui.EndChild()

      if lookup.selected then
        local rec = spellCache.spells[lookup.selected]
        if rec then
          ImGui.Separator()
          ImGui.Text(string.format('Selected: %s', rec.name))
          local canAdd = not buffListHas(rec.name)
          if not canAdd then
            ImGui.TextUnformatted('(Already in buff list)')
          end
          if ImGui.Button('Add Selected Spell') and canAdd then
            addBuffSpell(rec.name)
          end
        end
      end
    end

    ImGui.Separator()

    if ImGui.CollapsingHeader('Buff List (What gets cast)', ImGuiTreeNodeFlags.DefaultOpen) then
      if #settings.buffList == 0 then
        ImGui.TextUnformatted('(No buffs configured yet. Use Spell Lookup above to add spells.)')
      end

      for i,rec in ipairs(settings.buffList) do
        ImGui.PushID(i)
        local en = rec.enabled == true
        local ce
        ce, en = ImGui.Checkbox('##enabled', en)
        if ce then
          rec.enabled = en
          saveSettings()
        end
        ImGui.SameLine()
        ImGui.TextUnformatted(rec.name or '')

        ImGui.SameLine()
        if ImGui.Button('Up') then moveBuff(i, -1) end
        ImGui.SameLine()
        if ImGui.Button('Dn') then moveBuff(i, 1) end
        ImGui.SameLine()
        if ImGui.Button('Remove') then removeBuffIndex(i) end

        ImGui.PopID()
      end
    end

    ImGui.Separator()

    if ImGui.CollapsingHeader('Manual Test / Queue', ImGuiTreeNodeFlags.DefaultOpen) then
      ImGui.TextUnformatted('Last Status:')
      ImGui.TextUnformatted(state.lastStatus or '')

      ImGui.Separator()
      ImGui.Text(string.format('Queue: %d pending', #state.queue))
      if ImGui.Button('Process Queue Now') then
        processQueue()
      end
      ImGui.SameLine()
      if ImGui.Button('Clear Queue') then
        state.queue = {}
        state.lastStatus = 'Queue cleared.'
      end

      ImGui.Separator()
      ImGui.TextUnformatted('Test by name:')
      local testName = state.testName or ''
      local ed
      ed, testName = ImGui.InputText('##testname', testName, 64)
      if ed then state.testName = testName end
      ImGui.SameLine()
      if ImGui.Button('Enqueue Test') then
        if testName and testName ~= '' then
          enqueueRequest(testName)
          state.lastStatus = 'Enqueued test request for ' .. testName
        end
      end
    end

    ImGui.Separator()

    local dbgChanged
    dbgChanged, settings.showDebug = ImGui.Checkbox('Show debug panels', settings.showDebug)
    if dbgChanged then saveSettings() end
    if settings.showDebug then
      drawCacheStats()
    end

    ImGui.End()
  end)
  
  if not ok then
    ui.available = false
    ui.lastError = tostring(err)
    print(string.format('[%s] ImGui ERROR: %s', SCRIPT_NAME, err))
    print(string.format('[%s] Switching to HEADLESS mode. Tell trigger still active.', SCRIPT_NAME))
  end
end

-- -----------------------------
-- Init
-- -----------------------------
local function init()
  print(string.format('[%s] v%s initializing...', SCRIPT_NAME, SCRIPT_VER))
  
  loadSettings()
  loadSpellCache()
  
  ui.available = checkImGuiAvailable()
  
  if ui.available then
    print(string.format('[%s] ImGui functional - starting with UI', SCRIPT_NAME))
    local ok, err = pcall(function()
      mq.imgui.init(SCRIPT_NAME, drawUI)
    end)
    if not ok then
      print(string.format('[%s] ImGui init failed: %s', SCRIPT_NAME, tostring(err)))
      ui.available = false
    end
  end
  
  if not ui.available then
    print(string.format('[%s] ==========================================', SCRIPT_NAME))
    print(string.format('[%s] RUNNING IN HEADLESS MODE (No UI)', SCRIPT_NAME))
    print(string.format('[%s] Tell trigger is ACTIVE', SCRIPT_NAME))
    print(string.format('[%s] Queue processing is ACTIVE', SCRIPT_NAME))
    print(string.format('[%s] Trigger: "%s"', SCRIPT_NAME, settings.triggerText))
    print(string.format('[%s] ==========================================', SCRIPT_NAME))
  end
  
  print(string.format('[%s] Initialization complete. Enabled: %s', SCRIPT_NAME, tostring(settings.enabled)))
end

init()

-- -----------------------------
-- Main loop
-- -----------------------------
print(string.format('[%s] Entering main loop...', SCRIPT_NAME))

while true do
  mq.delay(25)
  mq.doevents()
  processQueue()
  
  if spellCache.state == CacheState.BUILDING then
    if settings.allowBackgroundCacheBuild or (ui.available and ui.open) then
      cacheBuildStep()
    end
  end
  
  if not ui.available and ui.lastError then
    ui.lastError = nil
  end
end
